from typing import Callable, Dict
from abc import ABC, abstractmethod
from kivy.logger import Logger
from sensors import SensorData, DirectionalDistances
from membership_function import CombinedMembershipFunctions, MembershipFunction
import random


class Turn(ABC):
    @abstractmethod
    def calculate(self) -> float:
        pass


class Move(ABC):
    @abstractmethod
    def calculate(self) -> float:
        pass


class ReactiveTurn(Turn):
    def __init__(
        self,
        sensor: SensorData,
        calculate_smooth_turn: Callable[[float], float],
        calculate_smooth_sharp_turn: Callable[[float], float],
    ) -> None:
        self.sensor = sensor
        self.calculate_smooth_turn = calculate_smooth_turn
        self.calculate_smooth_sharp_turn = calculate_smooth_sharp_turn

    def calculate(self) -> float:
        if self.sensor.is_front_safe():
            Logger.info("Safe Distance detected. Calculating smooth turn.")
            turn_value = self.calculate_smooth_turn(abs(self.sensor.smell()))
            return -turn_value if self.sensor.smell_food_on_left() else turn_value
        elif self.sensor.is_front_safe_either_close_by():
            Logger.warning("Object close by. Adjusting turn.")
            turn_value = self.calculate_smooth_turn(
                abs(
                    self.sensor.distances.front_left - self.sensor.distances.front_right
                )
            )
            return (
                -turn_value
                if self.sensor.distances.front_left > self.sensor.distances.front_right
                else turn_value
            )
        elif self.sensor.is_about_to_hit():
            Logger.error("Collision imminent! Executing sharp turn.")
            turn_value = self.calculate_smooth_sharp_turn(
                abs(
                    self.sensor.distances.front_left - self.sensor.distances.front_right
                )
            )
            return (
                -turn_value
                if self.sensor.distances.front_left > self.sensor.distances.front_right
                else turn_value
            )
        return 0


class ReactiveMove(Move):
    def __init__(
        self,
        sensor: SensorData,
        calculate_smooth_move: Callable[[float], float],
    ) -> None:
        self.sensor = sensor
        self.calculate_smooth_move = calculate_smooth_move

    def calculate(self) -> float:
        if self.sensor.is_front_safe_both_close_by():
            Logger.info("Front Sensor is clear.")
            return self.calculate_smooth_move(self.sensor.distances.front)
        return 0


class FuzzyTurn(Turn):
    def __init__(self, sensor: SensorData) -> None:
        self.sensor = sensor
        self.distance_msf = CombinedMembershipFunctions()
        self.distance_msf.add_membership(
            "close",
            MembershipFunction.create(function="gaussian", c=0.0, sigma=20.0),
        )
        self.distance_msf.add_membership(
            "medium",
            MembershipFunction.create(function="gaussian", c=30.0, sigma=20.0),
        )
        self.distance_msf.add_membership(
            "far",
            MembershipFunction.create(function="gaussian", c=100.0, sigma=20.0),
        )
        self.turn_msf = CombinedMembershipFunctions()
        self.turn_msf.add_membership(
            "little",
            MembershipFunction.create(
                function="trapezoidal", a=0.0, b=0.0, c=10.0, d=15.0
            ),
        )
        self.turn_msf.add_membership(
            "medium",
            MembershipFunction.create(
                function="trapezoidal", a=15.0, b=30.0, c=60.0, d=75.0
            ),
        )
        self.turn_msf.add_membership(
            "full",
            MembershipFunction.create(
                function="trapezoidal", a=70.0, b=80.0, c=90.0, d=90.0
            ),
        )

    def fuzzify_all_sides(self) -> DirectionalDistances:
        fuzzified_values = {}

        for side in DirectionalDistances._fields:
            distance = getattr(self.sensor.distances, side, None)
            if distance is not None:
                fuzzified_values[side] = self.distance_msf.fuzzify(distance)

        return DirectionalDistances(
            front=fuzzified_values["front"],
            front_right=fuzzified_values["front_right"],
            right=fuzzified_values["right"],
            back_right=fuzzified_values["back_right"],
            back=fuzzified_values["back"],
            back_left=fuzzified_values["back_left"],
            left=fuzzified_values["left"],
            front_left=fuzzified_values["front_left"],
        )

    def calculate(self) -> float:
        sensor: DirectionalDistances = self.fuzzify_all_sides()
        print(sensor)
        return 0


def distance() -> list:
    return [random.uniform(0, 100) for _ in range(8)]


def smell() -> list:
    return random.uniform(0, 100)


def smell_nearest() -> list:
    return random.uniform(0, 100)


def main():
    dummy_sensor = SensorData(
        distances=distance, smell=smell, smell_nearest=smell_nearest
    )
    turn = FuzzyTurn(sensor=dummy_sensor)
    turn.calculate()


if __name__ == "__main__":
    main()
